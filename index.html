// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IUniswapV2Router02 {
    function WETH() external view returns (address);

    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
}

contract PresaleLaunchpad is ReentrancyGuard, Ownable {
    using SafeERC20 for IERC20;

    // --- Token e router
    IERC20 public immutable token;
    IUniswapV2Router02 public immutable router;

    // --- Parâmetros da presale
    uint256 public presaleRate;    // tokens por 1 ETH (usar unidades token * 1 ether)
    uint256 public listingRate;    // tokens por 1 ETH usados para calcular liquidityTokens
    uint256 public minBuy;         // em wei
    uint256 public maxBuy;         // em wei por carteira (0 = sem limite)
    uint256 public softCap;        // em wei
    uint256 public hardCap;        // em wei (0 = sem limite)

    // Percentuais inteiros (ex: 10 = 10%)
    uint256 public feePercent = 10;       // taxa sobre totalETH enviada a feeWallet
    uint256 public liquidityPercent;      // % do ETH (após fee) que vai para liquidity

    address public feeWallet;

    // Horários (preenchidos conforme seu pedido)
    uint256 public startTime = 1765338600; // 2025-12-10 00:50 (UTC-3) -> UTC 2025-12-10 03:50
    uint256 public endTime   = 1765364400; // 2025-12-10 08:00 (UTC-3) -> UTC 2025-12-10 11:00

    // Estado
    uint256 public totalETH; // total em wei recebido
    bool public finalized;
    bool public canceled;

    mapping(address => uint256) public contributions; // em wei
    mapping(address => bool) public claimed;

    // Events
    event Bought(address indexed buyer, uint256 amountWei);
    event Refunded(address indexed buyer, uint256 amountWei);
    event Claimed(address indexed buyer, uint256 amountTokens);
    event Finalized(uint256 totalETH, uint256 feeETH, uint256 liquidityETH, uint256 liquidityTokens);
    event LiquidityAdded(uint256 tokenAmount, uint256 ethAmount, uint256 liquidity);
    event PresaleCanceled();

    // Constructor
    constructor(
        address _token,
        address _router,
        address _feeWallet,
        uint256 _presaleRate,
        uint256 _listingRate,
        uint256 _minBuy,
        uint256 _maxBuy,
        uint256 _softCap,
        uint256 _hardCap,
        uint256 _liquidityPercent
    ) Ownable(msg.sender) {
        require(_token != address(0), "token nulo");
        require(_router != address(0), "router nulo");
        require(_feeWallet != address(0), "feeWallet nulo");
        require(_liquidityPercent <= 100, "liquidityPercent invalido");

        token = IERC20(_token);
        router = IUniswapV2Router02(_router);
        feeWallet = _feeWallet;

        presaleRate = _presaleRate;
        listingRate = _listingRate;
        minBuy = _minBuy;
        maxBuy = _maxBuy;
        softCap = _softCap;
        hardCap = _hardCap;
        liquidityPercent = _liquidityPercent;
    }

    // -----------------------------
    // BUY (public para permitir chamadas internas de receive/fallback)
    // -----------------------------
    function buy() public payable nonReentrant {
        require(!finalized && !canceled, "presale encerrado");
        require(block.timestamp >= startTime, "presale nao iniciou");
        require(block.timestamp <= endTime, "presale terminou");

        require(msg.value >= minBuy, "abaixo do minBuy");

        if (maxBuy > 0) {
            require(contributions[msg.sender] + msg.value <= maxBuy, "excede maxBuy");
        }
        if (hardCap > 0) {
            require(totalETH + msg.value <= hardCap, "excede hardCap");
        }

        contributions[msg.sender] += msg.value;
        totalETH += msg.value;

        emit Bought(msg.sender, msg.value);
    }

    // fallback/receive para facilidade — chamam buy()
    receive() external payable {
        buy();
    }

    fallback() external payable {
        buy();
    }

    // -----------------------------
    // CLAIM (após finalize)
    // -----------------------------
    function claim() external nonReentrant {
        require(finalized, "nao finalizado");
        require(totalETH >= softCap, "softCap nao atingido");

        uint256 contributed = contributions[msg.sender];
        require(contributed > 0, "nenhuma contribuicao");

        contributions[msg.sender] = 0;

        uint256 amountTokens = (contributed * presaleRate) / 1 ether;
        require(amountTokens > 0, "zero tokens");

        token.safeTransfer(msg.sender, amountTokens);

        emit Claimed(msg.sender, amountTokens);
    }

    // -----------------------------
    // REFUND (se presale acabar e softCap não alcançado)
    // -----------------------------
    function refund() external nonReentrant {
        require(block.timestamp > endTime, "presale ainda ativa");
        require(!finalized, "ja finalizado");
        require(totalETH < softCap, "softCap atingido");

        uint256 contributed = contributions[msg.sender];
        require(contributed > 0, "nenhuma contribuicao");

        contributions[msg.sender] = 0;
        payable(msg.sender).transfer(contributed);

        emit Refunded(msg.sender, contributed);
    }

    // -----------------------------
    // FINALIZE (apenas owner, depois do endTime e se softCap alcançado)
    // -----------------------------
    function finalize() external onlyOwner nonReentrant {
        require(block.timestamp > endTime, "presale ainda ativa");
        require(!finalized, "ja finalizado");
        require(!canceled, "cancelado");
        require(totalETH >= softCap, "softCap nao atingido");

        finalized = true;

        uint256 feeETH = (totalETH * feePercent) / 100;
        if (feeETH > 0) {
            payable(feeWallet).transfer(feeETH);
        }

        uint256 ethAfterFee = totalETH - feeETH;
        uint256 liquidityETH = (ethAfterFee * liquidityPercent) / 100;

        uint256 totalTokensForSale = (totalETH * presaleRate) / 1 ether;
        uint256 liquidityTokens = (liquidityETH * listingRate) / 1 ether;

        uint256 neededTokens = totalTokensForSale + liquidityTokens;

        // owner deve ter aprovado launchpad para gastar neededTokens
        token.safeTransferFrom(owner(), address(this), neededTokens);

        if (liquidityETH > 0 && liquidityTokens > 0) {
            token.safeIncreaseAllowance(address(router), liquidityTokens);

            (uint amountToken, uint amountETH, uint liquidity) = router.addLiquidityETH{value: liquidityETH}(
                address(token),
                liquidityTokens,
                0,
                0,
                owner(),
                block.timestamp + 3600
            );

            emit LiquidityAdded(amountToken, amountETH, liquidity);
        }

        uint256 remainingETH = address(this).balance;
        if (remainingETH > 0) {
            payable(owner()).transfer(remainingETH);
        }

        emit Finalized(totalETH, feeETH, liquidityETH, liquidityTokens);
    }

    // -----------------------------
    // CANCELAR PRESALE (admin)
    // -----------------------------
    function cancelPresale() external onlyOwner {
        require(!finalized, "ja finalizado");
        canceled = true;
        emit PresaleCanceled();
    }

    // -----------------------------
    // FUNÇÕES ADMINISTRATIVAS
    // -----------------------------
    function setFeePercent(uint256 _feePercent) external onlyOwner {
        require(_feePercent <= 25, "fee > 25%");
        feePercent = _feePercent;
    }

    function setFeeWallet(address _feeWallet) external onlyOwner {
        require(_feeWallet != address(0), "feeWallet nulo");
        feeWallet = _feeWallet;
    }

    function setLiquidityPercent(uint256 _liquidityPercent) external onlyOwner {
        require(_liquidityPercent <= 100, "liquidity > 100");
        liquidityPercent = _liquidityPercent;
    }

    function updateRatesAndCaps(
        uint256 _presaleRate,
        uint256 _listingRate,
        uint256 _minBuy,
        uint256 _maxBuy,
        uint256 _softCap,
        uint256 _hardCap
    ) external onlyOwner {
        require(block.timestamp < startTime, "nao pode alterar apos inicio");
        presaleRate = _presaleRate;
        listingRate = _listingRate;
        minBuy = _minBuy;
        maxBuy = _maxBuy;
        softCap = _softCap;
        hardCap = _hardCap;
    }

    function rescueTokens(address _token, uint256 _amount) external onlyOwner {
        IERC20(_token).safeTransfer(owner(), _amount);
    }

    function rescueETH(uint256 _amount) external onlyOwner {
        require(finalized || canceled, "somente apos finalize/cancel");
        payable(owner()).transfer(_amount);
    }
}
