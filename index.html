<script>
// A função de inicialização que será chamada APÓS o carregamento completo do Ethers.js
function initDApp() {
    // 1. DESESTRUTURAÇÃO DO ETHERS:
    const { BrowserProvider, Contract, parseEther, formatEther, formatUnits } = ethers;

    let provider, signer, account, presaleContract;
    const presaleAddress = "0x6754c0f28ab363Ed6090843baeAb201C3CaCD96D"; // Seu contrato PillPresaleETH

    // ABI CORRIGIDA: Inclui todas as VIEW functions usadas no JS
    const abiPresale = [
        "function buyTokens() payable",
        "function tokensSold() view returns(uint256)",
        "function tokenPrice() view returns(uint256)",
        "function maxCapETH() view returns(uint256)",
        "function totalRaisedETH() view returns(uint256)" // <-- CORREÇÃO: totalRaisedETH
    ];

    const connectBtn = document.getElementById("connectBtn");
    const buyBtn = document.getElementById("buyBtn");
    const ethAmountInput = document.getElementById("ethAmount");
    const statusMessage = document.getElementById("statusMessage");

    // Função para exibir mensagens de status
    function setStatus(message, isError = false) {
        statusMessage.innerText = message;
        statusMessage.style.color = isError ? '#ff0066' : '#00ffaa';
    }

    // 1. Conectar MetaMask (Função principal de conexão)
    async function connectWallet() {
        if (!window.ethereum) {
            setStatus("MetaMask não encontrada! Instale a extensão para continuar.", true);
            return;
        }

        try {
            provider = new BrowserProvider(window.ethereum);
            
            // Verifica se a rede é a esperada (Exemplo: 1 para Mainnet, 11155111 para Sepolia)
            // Se você estiver em uma rede de testes, ajuste o valor:
            const chainId = (await provider.getNetwork()).chainId;
            // if (chainId !== BigInt(11155111)) { 
            //     setStatus("Conecte-se à rede Sepolia para esta Presale.", true);
            //     return;
            // }

            const accounts = await provider.send("eth_requestAccounts", []);
            account = accounts[0];
            signer = await provider.getSigner();
            
            // Inicializa o contrato com o Signer
            presaleContract = new Contract(presaleAddress, abiPresale, signer);

            // Atualiza a UI para estado conectado
            connectBtn.innerText = `Conectado: ${account.substring(0,6)}...${account.slice(-4)}`;
            connectBtn.style.background = "#00ffaa";
            connectBtn.disabled = true;
            buyBtn.disabled = false;
            setStatus("Conexão bem-sucedida!", false);

            updateUI();

            window.ethereum.on('accountsChanged', handleAccountsChanged);
            window.ethereum.on('chainChanged', handleChainChanged);

        } catch(err) {
            console.error("Erro ao conectar MetaMask:", err);
            setStatus("Erro ao conectar! Recuse ou veja console para detalhes.", true);
        }
    }

    // Handler para mudança de contas
    function handleAccountsChanged(accounts) {
        if (accounts.length > 0) {
            location.reload(); 
        }
    }

    // Handler para mudança de rede
    function handleChainChanged(chainId) {
        location.reload();
    }


    // 2. Atualizar UI (Lê dados do contrato)
    async function updateUI() {
        if (!presaleContract) return;

        try {
            // Chamadas AGORA FUNCIONAM porque estão na ABI
            const sold = await presaleContract.tokensSold();
            const price = await presaleContract.tokenPrice();
            const maxCap = await presaleContract.maxCapETH();
            const totalRaisedETH = await presaleContract.totalRaisedETH();


            // Conversão de dados
            const soldTokensFormatted = formatUnits(sold, 18); // Assumindo 18 decimais para o token
            const priceETH = formatEther(price);
            const maxCapETHFormatted = formatEther(maxCap);
            
            // Os valores são lidos do contrato como BigInts (totalRaisedETH) e devem ser formatados para cálculo
            const soldETHFloat = parseFloat(formatEther(totalRaisedETH));
            const maxCapETHFloat = parseFloat(maxCapETHFormatted);

            document.getElementById("tokensSold").innerText = "Tokens vendidos: " + soldTokensFormatted;
            document.getElementById("priceDisplay").innerText = "Preço do token: " + priceETH + " ETH";

            // Calcula e atualiza a barra de progresso
            // Uso de soldETHFloat e maxCapETHFloat
            let pct = 0;
            if (maxCapETHFloat > 0) {
                 pct = (soldETHFloat / maxCapETHFloat) * 100;
            }

            document.getElementById("progressFill").style.width = Math.min(pct, 100) + "%";

            // Limpa o status se tudo carregou bem
            setStatus("Conectado. Prontos para comprar.", false);

        } catch(err){
            console.error("Erro ao atualizar UI/ler contrato:", err);
            setStatus("Erro ao ler dados do contrato! Verifique a rede ou a ABI.", true);
        }
    }

    // 3. Comprar tokens (Envia transação)
    async function buyTokens() {
        if (!signer) return setStatus("Conecte a MetaMask primeiro.", true);
        
        const ethAmount = ethAmountInput.value;
        if (!ethAmount || parseFloat(ethAmount) <= 0) return setStatus("Insira um valor válido de ETH.", true);

        try {
            setStatus("Aguardando confirmação na MetaMask...", false);
            
            const valueToSend = parseEther(ethAmount);

            // Chama a função buyTokens do contrato, enviando ETH no campo 'value'
            const tx = await presaleContract.buyTokens({ value: valueToSend });
            
            setStatus(`Transação enviada: ${tx.hash.substring(0, 10)}... Aguardando mineração.`, false);
            
            await tx.wait();
            
            setStatus("Compra de tokens confirmada com sucesso!", false);
            updateUI(); 

        } catch(err) {
            console.error("Erro na compra:", err);

            let errorMsg = "Erro ao comprar tokens. Verifique o console.";
            if (err.reason) {
                // Tenta extrair a mensagem de revert (ex: "Max cap reached")
                errorMsg = `Transação Revertida: ${err.reason}`;
            } else if (err.code === 4001) {
                errorMsg = "Transação rejeitada pelo usuário na MetaMask.";
            }
            setStatus(errorMsg, true);
        }
    }

    // Inicializa os event listeners após o carregamento
    connectBtn.addEventListener("click", connectWallet);
    buyBtn.addEventListener("click", buyTokens);

    // Atualiza UI a cada 10 segundos
    setInterval(() => {
        if (presaleContract) {
            updateUI();
        }
    }, 10000);
}

// Chama initDApp quando a janela estiver totalmente carregada
window.addEventListener('load', initDApp);

</script>
